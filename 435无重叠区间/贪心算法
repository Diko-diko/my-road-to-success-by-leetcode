题目：
给定一个区间的集合，找到需要移除区间的最小数量，使剩余区间互不重叠。

注意:

    可以认为区间的终点总是大于它的起点。
    区间 [1,2] 和 [2,3] 的边界相互“接触”，但没有相互重叠。
    
思路:
1.分为三种情况：
（1）start1<start2&&end1>end2:将1删去保留2
（2）start1<start2&&end1>start2:将2删去保留1
（3）start1<start2&&end1<=start2:1和2都保留
以上可知：
（1）删去结尾离开头较长的，以便留出更多位置
（2）删去数字靠后的，保留数字靠前的，如以上第二种情况

2.重写Arrays.sort()函数：
Arrays.sort(intervals,new Comparator<int []>(){})此函数有这种形式
泛型的int[]指传入的参数类型为数组类型。
方法体的重写中a[1]-b[1]指对尾进行升序排序，[1]指数组中的第二项，而不是第二组数

3.
遍历排好序的数组，若end1<=start2,表示不用删去，count++,count指不用进行操作的项数
最后return len-count

class Solution {
    public int eraseOverlapIntervals(int[][] intervals) {
        int len=intervals.length;
        if(len==0) return 0;
        Arrays.sort(intervals,new Comparator<int[]>(){
            public int compare(int []a,int []b){
                return a[1]-b[1];
            }
        });
        int count=1;
        int end=intervals[0][1];
        for(int []inter:intervals){
            if(inter[0]>=end){
                count++;
                end=inter[1];
            }
        }
        return len-count;
    }
}
    
不过我没看出来哪里用了贪心？
